#!/usr/bin/env python2
# -*- mode: python; -*-
# -*- coding: utf-8 -*-
# vim: set fileencoding=utf-8

"""
    ibtopotool, a tool to do things with Infiniband topology.
    Copyright (C) 2013-2016  Janne Blomqvist

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""

import networkx as nx


def speed2weight(speed):
    """Convert an IB speed to an edge weight

    See e.g. https://en.wikipedia.org/wiki/InfiniBand

    """
    ss = speed.split('x')
    nlinks = int(ss[0])
    s1 = ss[1]
    if s1 == 'SDR':
        s = 2
    elif s1 == 'DDR':
        s = 4
    elif s1 == 'QDR':
        s = 8
    elif s1 == 'FDR':
        s = 13.64
    elif s1 == 'EDR':
        s = 24.24
    else:
        raise NotImplementedError('Support for Infiniband speed %s not implemented' % s1)
    return nlinks * s


def parse_ibtopo(topofile):
    """
    Parse an Infiniband topology file as generated by ibnetdiscover.

    Returns: A networkx graph representing the IB network
    """
    g = nx.DiGraph()
    switchidx = 0 # Index switches sequentially
    with open(topofile, 'r') as f:
        inblock = False # Switch or Host (Channel Adapter) block
        for line in f:
            if line.startswith('Switch'):
                inblock = True
                guid = line.split()[2][1:-1]
                i = line.index('#')
                s = line[i:].split('"')
                nodedesc = s[1]
                sid = "s%d" % switchidx
                g.add_node(guid, desc=nodedesc, type='Switch', label=sid)
                switchidx += 1
            elif line.startswith('Ca'):
                inblock = True
                guid = line.split()[2][1:-1]
                i = line.index('#')
                s = line[i:].split('"')
                nodedesc = s[1].split()[0]
                g.add_node(guid, label=nodedesc, type='Host')
            elif len(line) == 0 or line.isspace():
                inblock = False
            elif inblock:
                ls = line.split()
                destguid = ls[1].split('"')[1]
                w = speed2weight(ls[-1])
                g.add_edge(guid, destguid, weight=w)
    return g

def gen_dot(graph, out):
    from networkx.drawing.nx_pydot import write_dot
    write_dot(graph, out)

def gen_slurm(g, out):
    """
    g: A networkx graph representing the IB network
    out: Output file-like object
    """
    try:
        import hostlist
    except ImportError:
        print("""To generate a slurm topology.conf, you need to install
python-hostlist, https://pypi.python.org/pypi/python-hostlist""")
        raise
    out.write('# topology.conf generated by ibtopo2dot.py\n')
    for n, nbrs in g.adjacency_iter():
        if g.node[n]['type'] == 'Switch':
            switches = []
            nodes = []
            for nbr in nbrs:
                if g.node[nbr]['type'] == 'Switch':
                    switches.append(g.node[nbr]['label'])
                else:
                    nodename = g.node[nbr]['label']
                    nodes.append(nodename)
            switchstring = ""
            if len(switches) > 0:
                switches.sort()
                switchstring = " Switches=" + hostlist.collect_hostlist(switches)
            nodestr = ''
            if len(nodes) > 0:
                nodes.sort()
                nodestr = " Nodes=" + hostlist.collect_hostlist(nodes)
            out.write('SwitchName=%s%s%s\n' % (g.node[n]['label'],
                                               switchstring, nodestr))


def treeify(g, rootfile):
    """Generate a DAG with roots given in the file rootfile"""
    roots = []
    with open(rootfile, 'r') as f:
        for line in f:
            l = line.strip()
            if l.startswith('#'):
                continue
            ii = l.find('#')
            if ii >= 1:
                l = l[:ii]
            roots.append(l)
    # Unfortunately, bfs_tree drops all attributes. Save them
    # manually, reapply them later
    nattrs_type = nx.get_node_attributes(g, 'type')
    nattrs_desc = nx.get_node_attributes(g, 'desc')
    nattrs_label = nx.get_node_attributes(g, 'label')
    eattrs_weight = nx.get_edge_attributes(g, 'weight')
    gdag = nx.DiGraph()
    for root in roots:
        gdag = nx.compose(gdag, nx.bfs_tree(g, root))
    nx.set_node_attributes(gdag, 'type', nattrs_type)
    nx.set_node_attributes(gdag, 'desc', nattrs_desc)
    nx.set_node_attributes(gdag, 'label', nattrs_label)
    # A fun thing with set_edge_attributes, is that it fails if an
    # edge tuple is missing. So first manually remove missing tuples.
    todel = []
    for t in eattrs_weight:
        if t not in gdag:
            todel.append(t)
    for t in todel:
        del eattrs_weight[t]
    nx.set_edge_attributes(gdag, 'weight', eattrs_weight)
    # Mark the roots with color for graphviz
    for root in roots:
        gdag.node[root]['fillcolor'] = 'red'
        gdag.node[root]['style'] = 'filled'
    return gdag

def only_switches(g):
    """Filter out nodes that are not switches"""
    return g.subgraph([n for n, attrs in g.node.items() if attrs['type']
                       == 'Switch'])

if __name__ == '__main__':
    from optparse import OptionParser
    import sys
    usage = """%prog [options] ibtopofile

ibtopofile is a file containing the output of 'ibnetdiscover'."""
    parser = OptionParser(usage)
    parser.add_option('-s', '--switches', dest='switches', 
                      action='store_true',
                      help='Include only switch nodes')
    parser.add_option('-o', '--output', dest='output',
                      help='Output file, if omitted stdout')
    parser.add_option('--slurm', dest='slurm', action='store_true',
                      help='Output in slurm topology.conf format')
    parser.add_option('--treeify', dest='treeify',
                      help="Give a file containing GUID's for spine switches")
    (options, args) = parser.parse_args()
    graph = parse_ibtopo(args[0])
    if options.output:
        out = open(options.output, 'w')
    else:
        out = sys.stdout
    if options.switches:
        graph = only_switches(graph)
    if options.treeify:
        graph = treeify(graph, options.treeify)
    if options.slurm:
        gen_slurm(graph, out)
    else:
        gen_dot(graph, out)
